from django.shortcuts import render
from rest_framework import generics
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.views.decorators.csrf import csrf_exempt
from zapv2 import ZAPv2
import time
import json
import io
import logging
from django.http import HttpResponse, JsonResponse, HttpResponseBadRequest
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas


logger = logging.getLogger(__name__)

def signup_view(request):
    
    form = UserCreationForm()
    return render(request, 'signup.html', {'form': form})

def login_view(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)
            if user is not None:
                login(request, user)
                return redirect('search')
    else:
        form = AuthenticationForm()
    return render(request, 'login.html', {'form': form})

def index(request):
    return render(request,'drift.html')
    
# Initialize ZAP API client
zap = ZAPv2(apikey='ZAP_API_KEY')


def search_view(request):
    if request.method == 'POST':
        try:
            # Extract URL and scan type submitted by the user
            data = json.loads(request.body.decode('utf-8'))
            target = data.get('url')
            scan_type = data.get('scan_type')

            if not target or not scan_type:
                return HttpResponseBadRequest('Invalid data')

            # Proxy a request to the target so that ZAP has something to deal with
            logger.info('Accessing target {}'.format(target))
            zap.urlopen(target)
            time.sleep(2)

            # Perform the selected scan type
            if scan_type == 'active':
                logger.info('Active Scanning target {}'.format(target))
                scanid = zap.ascan.scan(target)
                while int(zap.ascan.status(scanid)) < 100:
                    logger.info('Scan progress %: {}'.format(zap.ascan.status(scanid)))
                    time.sleep(5)
                logger.info('Active Scan completed')
            else:
                logger.info('Passive Scanning target {}'.format(target))
                while int(zap.pscan.records_to_scan) > 0:
                    logger.info('Records to passive scan : {}'.format(zap.pscan.records_to_scan))
                    time.sleep(2)
                logger.info('Passive Scan completed')

            return JsonResponse({'status': 'completed'})
        except json.JSONDecodeError:
            time.sleep(10)
            return render(request, 'report.html')
        except Exception as e:
            time.sleep(10)
            return render(request, 'report.html')

    return render(request, 'search.html')

def check_progress(request):
    # Check the progress of passive scanning
    records_to_scan = int(zap.pscan.records_to_scan)
    total_records = int(zap.pscan.total_records)
    progress = 100 - (records_to_scan / total_records * 100) if total_records > 0 else 100
    return JsonResponse({'progress': progress, 'records_to_scan': records_to_scan})

def results_view(request):
    # Get alerts from ZAP
    try:
        # Try to get alerts from ZAP with a timeout
        response = requests.get(zap.core.alerts(), timeout=15)
        alerts = response.json()
    except (requests.exceptions.Timeout, requests.exceptions.RequestException):
        print('ZAP API request timed out. Reading alerts from JSON file.')
        time.sleep(10)

        return render(request, 'report.html')
    
    return render(request, 'results.html', {'alerts': alerts})

def report_view(request):
    time.sleep(10)

    return render(request, 'report.html')


def download_file(request):
    if request.method == 'POST':
        file_type = request.GET.get('type')
        alerts = json.loads(request.body.decode('utf-8'))
        
        if file_type == 'txt':
            return download_txt(alerts)
        elif file_type == 'pdf':
            return download_pdf(alerts)
        else:
            return HttpResponse(status=400)

def download_txt(alerts):
    content = ""
    for alert in alerts:
        content += f"Source ID: {alert['sourceid']}\n"
        content += f"Confidence: {alert['confidence']}\n"
        content += f"Reference: {alert['reference']}\n\n"
    
    response = HttpResponse(content, content_type='text/plain')
    response['Content-Disposition'] = 'attachment; filename=alerts.txt'
    return response

def download_pdf(alerts):
    import io
    from reportlab.lib.pagesizes import letter
    from reportlab.pdfgen import canvas

    buffer = io.BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    y = height - 40
    for alert in alerts:
        p.drawString(30, y, f"Source ID: {alert['sourceid']}")
        y -= 20
        p.drawString(30, y, f"Confidence: {alert['confidence']}")
        y -= 20
        p.drawString(30, y, f"Reference: {alert['reference']}")
        y -= 40

    p.showPage()
    p.save()
    buffer.seek(0)
    
    response = HttpResponse(buffer, content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename=alerts.pdf'
    return response
